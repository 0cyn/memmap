#!/usr/bin/env python3

import curses
import sys
import os
from pprint import pprint
import getopt

SROM = 0
DFU = 1
IBOT = 2

debug = False

HEADER = """------

%s - Memory layout and address information for %s
Generated by memmap.py

------

"""

SOCS = {
    't8002':[
        { 
        #   Evaluation of memmap for t8002
        #   -DAPPLICATION_SECUREROM
        #
        'SDRAM_BASE' : (0x80000000),
        'SDRAM_LEN' : (0x20000000 ),
        'SDRAM_BANK_LEN' : (0x20000000),
        'SDRAM_BANK_COUNT' : (1),
        'SDRAM_END' : (0x80000000 + 0x20000000),
        'VROM_BASE' : (0x40000000),
        'VROM_BANK_LEN' : (0x00100000),
        'VROM_LEN' : (0x00040000),
        'SRAM_BASE' : (0x48800000),
        'SRAM_LEN' : (0x00120000),
        'SRAM_BANK_LEN' : (0x00120000),
        'SRAM_BANK_COUNT' : (1),
        'SRAM_END' : (0x48800000 + 0x00120000),

        'IO_BASE' : (0x40000000),
        'IO_SIZE' : (0x20000000),

        'SECUREROM_LOAD_ADDRESS' : (0x80000000),

        'TZ0_SIZE' : ( 8*1024*1024 ),
        'TZ0_BASE' : ((0x80000000 + 0x20000000) - ( 8*1024*1024 )),

        'ASP_SIZE' : (0x00500000),
        'ASP_BASE' : (((0x80000000 + 0x20000000) - ( 8*1024*1024 )) - 0x00500000),

        'CONSISTENT_DEBUG_SIZE' : (0x00004000),
        'CONSISTENT_DEBUG_BASE' : ((((0x80000000 + 0x20000000) - ( 8*1024*1024 )) - 0x00500000) - 0x00004000),

        'SLEEP_TOKEN_BUFFER_SIZE' : (0x00001000),
        'SLEEP_TOKEN_BUFFER_BASE' : (((((0x80000000 + 0x20000000) - ( 8*1024*1024 )) - 0x00500000) - 0x00004000) - 0x00001000),

        'DRAM_CONFIG_SEQ_SIZE' : (0x00004000),
        'DRAM_CONFIG_SEQ_BASE' : ((((((0x80000000 + 0x20000000) - ( 8*1024*1024 )) - 0x00500000) - 0x00004000) - 0x00001000) - 0x00004000),

        'PANIC_SIZE' : (0x00080000),
        'PANIC_BASE' : (((((((0x80000000 + 0x20000000) - ( 8*1024*1024 )) - 0x00500000) - 0x00004000) - 0x00001000) - 0x00004000) - 0x00080000),

        'DISPLAY_SIZE' : (4*1024*1024),
        'DISPLAY_BASE' : ((((((((0x80000000 + 0x20000000) - ( 8*1024*1024 )) - 0x00500000) - 0x00004000) - 0x00001000) - 0x00004000) - 0x00080000) - (4*1024*1024)),

        'DATA_BASE' : (0x48800000),
        'DATA_SIZE' : (0x00007000),

        'BOOK_KEEPING_BASE' : (0x48800000 + 0x00007000),
        'BOOT_TRAMPOLINE_BASE' : (0x48800000 + 0x00007000),
        'BOOT_TRAMPOLINE_SIZE' : (0x00001000),
        'MMU_TT_BASE' : ((0x48800000 + 0x00007000) + 0x00001000),
        'MMU_TT_SIZE' : (0x00004000 ),
        'STACK_BASE' : ((0x48800000 + 0x00007000) + 0x00001000 + 0x00004000 ),
        'STACK_SIZE' : (0x00004000),
        'BOOK_KEEPING_SIZE' : (0x00001000 + 0x00004000 + 0x00004000),

        'HEAP_BASE' : ( (0x48800000 + 0x00007000) + (0x00001000 + 0x00004000 + 0x00004000)),
        'HEAP_SIZE' : (0x00008000),
        'HEAP_END' : (( (0x48800000 + 0x00007000) + (0x00001000 + 0x00004000 + 0x00004000)) + (0x00008000)),

        'INSECURE_MEMORY_SIZE' : ((0x48800000 + 0x00120000) - (( (0x48800000 + 0x00007000) + (0x00001000 + 0x00004000 + 0x00004000)) + (0x00008000))),
        'INSECURE_MEMORY_BASE' : ((( (0x48800000 + 0x00007000) + (0x00001000 + 0x00004000 + 0x00004000)) + (0x00008000)))
    }]
}


class CursesMenu(object):

    INIT = {'type' : 'init'}

    def __init__(self, menu_options):

        self.screen = curses.initscr()
        self.menu_options = menu_options
        self._root_menu = menu_options
        self.selected_option = 0
        self._previously_selected_option = None
        self.menu_trace = []
        self.running = True

        #init curses and curses input
        curses.noecho()
        curses.cbreak()
        curses.start_color()
        curses.curs_set(0) #Hide cursor
        self.screen.keypad(1)

        #set up color pair for highlighted option
        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_WHITE)
        self.hilite_color = curses.color_pair(1)
        self.normal_color = curses.A_NORMAL

    def prompt_selection(self, parent=None):
        if parent is None:
            lastoption = "Exit"
        else:
            lastoption = "Return to previous menu ({})".format(parent['title'])

        option_count = len(self.menu_options['options'])

        input_key = None

        ENTER_KEY = ord('\n')
        while input_key != ENTER_KEY:
            if self.selected_option != self._previously_selected_option:
                self._previously_selected_option = self.selected_option

            self.screen.border(0)
            self._draw_title()
            for option in range(option_count):
                if self.selected_option == option:
                    self._draw_option(option, self.hilite_color)
                else:
                    self._draw_option(option, self.normal_color)

            if self.selected_option == option_count:
                self.screen.addstr(5 + option_count, 4, "{:2} - {}".format(option_count+1,
                    lastoption), self.hilite_color)
            else:
                self.screen.addstr(5 + option_count, 4, "{:2} - {}".format(option_count+1,
                    lastoption), self.normal_color)

            max_y, max_x = self.screen.getmaxyx()
            if input_key is not None:
                self.screen.addstr(max_y-3, max_x - 5, "{:3}".format(self.selected_option))
            self.screen.refresh()


            input_key = self.screen.getch()
            down_keys = [curses.KEY_DOWN, ord('j')]
            up_keys = [curses.KEY_UP, ord('k')]
            exit_keys = [ord('q')]

            if input_key in down_keys:
                if self.selected_option < option_count:
                    self.selected_option += 1
                else:
                    self.selected_option = 0

            if input_key in up_keys:
                if self.selected_option > 0:
                    self.selected_option -= 1
                else:
                    self.selected_option = option_count

            if input_key in exit_keys:
                self.selected_option = option_count #auto select exit and return
                break

        return self.selected_option

    def _draw_option(self, option_number, style):
        self.screen.addstr(5 + option_number,
                           4,
                           "{:2} - {}".format(option_number+1, self.menu_options['options'][option_number]['title']),
                           style)

    def _draw_title(self):
        self.screen.addstr(2, 2, self.menu_options['title'], curses.A_STANDOUT)
        self.screen.addstr(4, 2, self.menu_options['subtitle'], curses.A_BOLD)

    def display(self):
        selected_option = self.prompt_selection(self._previously_selected_option)
        i, _ = self.screen.getmaxyx()
        self.screen.clear()
        curses.endwin()

        depth = len(self.menu_trace)
        
        if selected_option < len(self.menu_options['options']):
            selected_opt = self.menu_options['options'][selected_option]
            if 'options' in selected_opt:
                self._previously_selected_option = selected_opt
                self.menu_options = selected_opt
                self.menu_trace.append(selected_opt)
                
                sub = self.display()
                if sub[0]['type'] == 'exitmenu':
                    self.menu_trace.pop()
                    self.menu_options = self.menu_trace[len(self.menu_trace)-1] if len(self.menu_trace) > 0 else self._root_menu
                    self._previously_selected_option = self.menu_trace[len(self.menu_trace)-2] if len(self.menu_trace) > 1 else None
                    self.screen = curses.initscr()
                    self.display()
            else:
                self.menu_trace.append(selected_opt)
            return self.menu_trace if len(self.menu_trace) > 0 else [{'title' : 'Exit', 'type' : 'exitmenu'}]
        else:
            if depth == 0:
                self.running = False
            return [{'title' : 'Exit', 'type' : 'exitmenu'}]

def main(argv):

    
    vf = False
    sparse = False
    vfilter = []
    soc_passed = None
    model_passed = None
    targ_passed = None 
    soc = None
    seg = None
    arg = None

    memlen = 8

    if '-d' in argv:
        global debug
        debug = True

    if len(argv) > 1:
        narg = None 
        l = ''
        for opt in argv:
            optn = opt
            if debug:
                print("%s %s %s" % (optn, l, str(narg)))
            if optn in ("-h", "--help"):
                print('memmap.py -h -x --soc=[soc] --model=[model] --target=[target] --value [variable] [variable2]...')
                print('-----')
                print('Ommiting soc/model or target will launch an interactive GUI where you can select them :)')
                print('-----')
                print('-h | --help   - Print this menu and exit')
                print('-x            - Print nothing but the addresses, use for piping --value output elsewhere')
                print('-s | --soc    - Specify a SOC (e.g. t8002')
                print('-m | --model  - Specify model (e.g. Watch2,3')
                print('-t | --target - Specify the targeted portion of iBoot (0=SecureRom, 1=LLB iBSS DFU, 2=iBoot iBEC)')
                print('-v | --value  - Display only the variables after this argument')
                exit(0)
            if optn == '-x':
                sparse = True

            if narg:
                arg = optn
                optn = l

            if optn in '-s -m -t' and not narg:
                narg = True 
                l = optn
                continue
            
            if arg and optn in '-s':
                soc_passed = arg 
            elif arg and optn in '-m':
                model_passed = arg 
            elif arg and optn in '-t':
                targ_passed = int(arg)

            elif optn in ("-v", "--value"):
                vfilter = argv[argv.index(opt)+1:]
                break

            narg = False

    if debug:
        print("Args Parsed: -s %s -m %s -t %s" % (soc_passed, model_passed, targ_passed))
        print("sparse: %s" % str(sparse))
        print("vfilter: %s" % str(vfilter))

    socs = {'title' : 'SOCs',
    'type' : 'menu',
    'subtitle' : 'Select target chip'}

    Sec = {'title' : 'SecureRom',
                'type' : 'item',
                'value' : 0}
    Dfu = {'title' : 'LLB, iBSS DFU',
                'type' : 'item',
                'value' : 1}
    Ibo = {'title' : 'iBoot, iBEC',
                'type' : 'item',
                'value' : 2}

    segopts = [Sec, Dfu, Ibo]

    t8002 = {'title' : 't8002 - Watch2,3 Watch2,4 Watch2,6 Watch2,7',
                'value': 't8002',
                'memlen': 8,
                'type' : 'menu',
                'subtitle' : 'Select Target' }

    socs['options'] = [t8002]

    main_menu = socs

    if soc_passed:
        for i in socs['options']:
            if soc_passed in i['title']:
                soc = i['value']
                memlen = i['memlen']
                main_menu = i

    if model_passed:
        for i in socs['options']:
            if model_passed in i['title']:
                soc = i['value']
                memlen = i['memlen']
                main_menu = i
    
    if targ_passed is not None:
        if targ_passed in range(0,3):
            seg = targ_passed
        else:
            raise IndexError("( -t %s ) Valid values are 0 (SecureRom), 1 (LLB, IBSS DFU), and 2 (iBoot, iBEC)" % targ_passed )
    else:
        for i in socs['options']:
            i['options'] = segopts

    if not soc or seg is None:
        if not sparse:   
            m = CursesMenu(main_menu)
            sels = m.display()

            if sels[0]['type'] == 'exitmenu':
                exit(0)
        if not soc:
            soc = sels[0]['value']
            memlen = sels[0]['memlen'] # soc wasnt set on cli
        elif seg is None:
            seg = sels[0]['value'] # seg wasn't set on cli, but soc was
        if seg is None:
            soc = sels[0]['value'] 
            memlen = sels[0]['memlen']# neither were set on cli 
            seg = sels[1]['value'] # beautiful

    try:
        memmap = SOCS[soc][seg]
    except IndexError:
        try:
            _ = SOCS[soc]
            print("%s for %s hasn't been added yet." % (segopts[seg]['title'], soc))
        except IndexError:
            print("%s is not yet in the database. Run without arguments for a list of currently added SOCs")
        exit(2)

    if not sparse:
        print(HEADER % (soc, segopts[seg]['title']))
    if not vf:
        for key in memmap:
            if sparse:
                print("0x%s" % hex(memmap[key])[2:].zfill(memlen), end =" ")
            else:
                print("%s -> 0x%s" % (key, hex(memmap[key])[2:].zfill(memlen)))
    else:
        for key in vfilter:
            if sparse:
                print("0x%s" % hex(memmap[key])[2:].zfill(memlen), end =" ")
            else:
                print("%s -> 0x%s" % (key, hex(memmap[key])[2:].zfill(memlen)))
        
try:
    main(sys.argv)
except Exception as ex:
    try:
        curses.endwin()
    except Exception:
        pass
    
    if debug:
        raise ex 
    else:
        print(str(type(ex)).split("'")[1] + ": " + str(ex))
        exit(1)
